//@ts-check

try {
//Rhino's const is a global scope, which will report an error!
    var { requireShared } = require("./src/requireShared.js");
    /**
     * @type {import("../shared/runtimes.js")}
     */
    var runtimes = requireShared("runtimes.js");
    var calibrateLayout = require("./src/ui/calibrateLayout.js");
    var MusicFormats = require("./src/musicFormats.js");
    var MidiDeviceManager = require("./src/midiDeviceManager.js");
    var GameProfile = require("./src/gameProfile.js");
    var Visualizer = require("./src/visualizer.js");
    var FileChooser = require("./src/fileChooser.js");
    var { PlayerType, AutoJsGesturePlayer, SimpleInstructPlayer, SkyCotlLikeInstructPlayer } = require("./src/players.js");
    var configuration = require("./src/configuration.js");
    var passes = require("./src/passes.js");
    var midiPitch = require("./src/midiPitch.js");
    var noteUtils = require("./src/noteUtils.js");
    var LrcParser = require("./src/frontend/lrc.js")
    var { ConfigurationUi, ConfigurationFlags } = require("./src/ui/config_ui.js");
    var FileProvider = require("./src/fileProvider.js");
    var FileSelector = require("./src/ui/fileSelector.js");
    /**
     * @type {import("../shared/FloatButton/FloatButton.js")}
     */
    var FloatButton = requireShared("FloatButton/FloatButton.js");
} catch (e) {
    toast("Please do not download/copy this script separately. You need to download all the files in 'Chu Liuxiang Music Box'!") ;

Toast ("module loading error");
    toast(e);
    console.error(e);
}

const musicDir = configuration.getMusicDir();
const scriptVersion = 27;

//If you encounter a strange problem, you can remove the first two slashes of the following line of code, and then run the script again to clear the current configuration file.
//setGlobalConfig("userGameProfile", null);


//Print the intermediate results generated by the script in the log, optional: parse, humanify, key, timing, merge, gestures
const debugDumpPass = "";

//The application name will be initialized later.
let appName = undefined;

let musicFormats = new MusicFormats();
let gameProfile = new GameProfile();
let visualizer = new Visualizer();
let fileProvider = new FileProvider();

const setGlobalConfig = configuration.setGlobalConfig;
const readGlobalConfig = configuration.readGlobalConfig;
const haveFileConfig = configuration.haveFileConfig;
const setFileConfig = configuration.setFileConfig;
const readFileConfig = configuration.readFileConfig;

/**
 * @brief The format type of exported data
 * @enum {string}
 */
const ScoreExportType = {
    none: "none",
    keyboardScore: "keyboardScore",
    keySequenceJSON: "keySequenceJSON",
};

/**
 * @enum {string}
 */
const ScriptOperationMode = {
    NotRunning: "NotRunning",
    FilePlayer: "FilePlayer",
    MIDIInputStreaming: "MIDIInputStreaming",
};

/**
 * @enum {string}
 */
const MusicLoaderDataType = {
    GestureSequence: "GestureSequence",
    KeySequence: "KeySequence",
    KeySequenceHumanFriendly: "KeySequenceHumanFriendly",
};

/**
 * @brief Load the configuration file
 */
function loadConfiguration() {
    try {
        // TODO: Custom configuration
        // let userGameProfile = readGlobalConfig("userGameProfile", null);
        // if (userGameProfile != null) {
        //     gameProfile.loadGameConfigs(userGameProfile);
        // } else {
        //     gameProfile.loadDefaultGameConfigs();
        // }
        gameProfile.loadDefaultGameConfigs();
        let keyLocators = readGlobalConfig("keyLocators2",null);
        console.log("keyLocators2: " + JSON.stringify(keyLocators));
        if(keyLocators == null)
            gameProfile.setKeyLocators(new Map());
        else
            gameProfile.setKeyLocators(keyLocators);

        let lastConfigName = readGlobalConfig("lastConfigName", "");
        //Try to load the game configuration set by the user
        let activeConfigName = readGlobalConfig("activeConfigName", null);
        let res = gameProfile.setConfigByName(activeConfigName);
        if (res == false) {
            console.log("Try to load the game configuration set by the user... Failure!");
        } else {
            console.log("Try to load the game configuration set by the user... Success, current configuration: " + gameProfile.getCurrentConfigTypeName());
        }

        //Try to load the game configuration through the package name (keep the current configuration after loading fails)
        if (auto.service != null) {
            let currentPackageName = currentPackage();
            console.log("Current package name:" + currentPackageName);
            res = gameProfile.setConfigByPackageName(currentPackageName);
            if (res == false) {
                console.log("Try to load the game configuration through the package name... Be defeated!");
            } else {
                console.log("Try to load the game configuration through the package name... Success, current configuration: " + gameProfile.getCurrentConfigTypeName());
                //Save the current configuration
                setGlobalConfig("activeConfigName", gameProfile.getCurrentConfigTypeName());
            }
        } else {
            console.log("Barrier-free service is not enabled. Skip the attempt to load the game configuration through the package name.");
        }

        if (gameProfile.getCurrentConfig() == null) {
            console.error("No suitable configuration was found. The default configuration has been loaded!");
            toast("No suitable configuration was found. The default configuration has been loaded!");
            gameProfile.setConfigByName("Chu Liuxiang");
        }

        if (lastConfigName != gameProfile.getCurrentConfigTypeName()) {
            //If the configuration has changed, empty the previous variant and key configuration.
            setGlobalConfig("lastConfigName", gameProfile.getCurrentConfigTypeName());
            setGlobalConfig("lastVariantName", "");
            setGlobalConfig("lastKeyTypeName", "");
        }

        //Load variant configuration and key configuration
        let lastVariantName = readGlobalConfig("lastVariantName", "");
        if (lastVariantName != "") {
            let res = gameProfile.setCurrentVariantByTypeName(lastVariantName);
            if (res == false) {
                console.log("Try to load the variant configuration set by the user... Be defeated!");
                gameProfile.setCurrentVariantDefault();
            } else {
                console.log("Try to load the variant configuration set by the user... Success");
            }
        } else {
            gameProfile.setCurrentVariantDefault();
            console.log("The game configuration has changed, and the default variant configuration has been loaded.");
        }
        setGlobalConfig("lastVariantName", gameProfile.getCurrentVariantTypeName());

        let lastKeyTypeName = readGlobalConfig("lastKeyTypeName", "");
        if (lastKeyTypeName != "") {
            let res = gameProfile.setCurrentKeyLayoutByTypeName(lastKeyTypeName);
            if (res == false) {
                console.log("Try to load the key configuration set by the user... Be defeated!");
                gameProfile.setCurrentKeyLayoutDefault();
            } else {
                console.log("Try to load the key configuration set by the user... Success");
            }
        } else {
            gameProfile.setCurrentKeyLayoutDefault();
            console.log("The game configuration has changed, and the default key configuration has been loaded.");
        }
        setGlobalConfig("lastKeyTypeName", gameProfile.getCurrentKeyLayoutTypeName());

    } catch (error) {
        toastLog("Failed to load the configuration file! The default configuration has been automatically loaded!");
        console.warn(error);
        gameProfile.loadDefaultGameConfigs();
        setGlobalConfig("userGameProfile", null);
    }
}

/**
 * Start midi streaming
 * @returns {{
 *  onDataReceived: (callback: (data: Array<Uint8Array>) => void) => void,
 *  close: () => void,
 * } | null}
 */
function setupMidiStream() {
    const midiEvt = events.emitter(threads.currentThread());
    /** @type {MidiDeviceManager} */
    //@ts-ignore
    let midi = null;
    const midiThread = threads.start(function () {
        setInterval(function () {}, 1000);
        midi = new MidiDeviceManager();
    });
    midiThread.waitFor();
    while (midi == null) {
        sleep(100);
    }
    let devNames = [];
    while (1) {
        devNames = midi.getMidiDeviceNames();
        if (devNames.length == 0) {
            if (!dialogs.confirm(
                "Wrong", 
                "No MIDI equipment was found., Click OK to try again, and click Cancel to quit.\n" + 
                "Prompt: If you want to use Bluetooth MIDI devices, please install plug-ins to connect according to the relevant tutorials in the instructions." 
                )) {
                return null;
            }
        } else {
            break;
        }
    }
    let deviceIndex = dialogs.select("Choose MIDI equipment", devNames);
    if (deviceIndex == -1) {
        toast("You canceled the selection.");
        return null;
    }
    let portNames = midi.getMidiPortNames(deviceIndex);
    if (portNames.length == 0) {
        dialogs.alert("Wrong", "There is no available port for this MIDI device.");
        return null;
    }
    let portIndex = 0;
    if (portNames.length > 1) {  // It is unlikely to appear.
        portIndex = /** @type {Number} */ (dialogs.select("Select the MIDI port", portNames));
        if (portIndex == -1) {
            toast("You canceled the selection.");
            return null;
        }
    }
    midiThread.setImmediate(() => {
        midi.openDevicePort(deviceIndex, portIndex);
        midi.setDataReceivedCallback(() => {
            midiEvt.emit("dataReceived");
        });
    });

    let _onDataReceived = (data) => { };

    midiEvt.on("dataReceived", () => {
        let keyList = [];
        if (!midi.dataAvailable()) {
            return;
        }
        while (midi.dataAvailable()) {
            _onDataReceived(midi.readAll());
        }
    });

    return {
        onDataReceived: (callback) => {
            _onDataReceived = callback;
        },
        close: () => {
            midi.close();
            midiThread.interrupt();
        }
    }
}

function checkEnableAccessbility() {
    //Start the barrier-free service
    console.verbose("Waiting for barrier-free services..");
    //toast("Please allow the barrier-free permissions of this application.");
    if (auto.service == null) {
        toastLog(`Please open the app. "${appName}" Barrier-free permissions!`);
        auto.waitFor();
        toastLog(`Barrier-free permissions have been turned on! Please go back to the game and click to play again.`);
        return false;
    }
    console.verbose("Barrier-free service has been launched.");
    return true;
}

/**
 * @param {noteUtils.PackedNoteLike[]} noteData Note data
 * @param {ScoreExportType} exportType Export type
 * @brief Export note data
 */
function exportNoteDataInteractive(noteData, exportType) {
    switch (exportType) {
        case ScoreExportType.keyboardScore:
            let maxDelayTime = 0;
            let confirmed = false;
            let gapTime = 0;
            while (!confirmed) {
                gapTime = dialogs.input("Enter the time difference between two notes when you intend to divide them into two segments (unit: milliseconds)", maxDelayTime.toString());
                if (gapTime < 10) dialogs.alert("", "The input is invalid, please re-enter.");
                let segmentCnt = 1;
                noteData.forEach(key => {
                    if (key[1] >= gapTime) segmentCnt++;
                });
                confirmed = /** @type {Boolean} */ (dialogs.confirm("", "The score will be divided into" + segmentCnt.toString() + "个小段,是否满意?"));
            }

            let toneStr = null;
            switch (dialogs.select("Select the export format", ["Chu Liuxiang (keyboard)", "Genshin Impact (keyboard)", "_Simple score_"])) {
                case 0:
                    if (gameProfile.getCurrentKeyLayoutTypeName() !== "generic_3x7") {
                        dialogs.alert("Wrong", "The currently selected game key and the export format do not match. Please choose 3x7 key.");
                        return;
                    }
                    toneStr = "ZXCVBNMASDFGHJQWERTYU";
                    break;
                case 1:
                    if (gameProfile.getCurrentKeyLayoutTypeName() !== "generic_3x7") {
                        dialogs.alert("Wrong", "The currently selected game key and the export format do not match. Please choose 3x7 key.");
                        return;
                    }
                    toneStr = "ZXCVBNMASDFGHJQWERTYU";
                    break;
                case 2:
                    if (gameProfile.getCurrentKeyLayoutTypeName() !== "generic_3x7") {
                        dialogs.alert("Wrong", "The currently selected game key and the export format do not match. Please choose 3x7 key.");
                        return;
                    }
                    toneStr = "₁₂₃₄₅₆₇1234567¹²³⁴⁵⁶⁷"; //TODO: The simplified spectrum format here may need to be adjusted.
            }
            //Start to convert
            let outPutStr = "";
            noteData.forEach(key => {
                if (key[0].length > 1) {
                    //Sort from treble to bass
                    key[0].sort((a, b) => {
                        return b - a;
                    });
                    outPutStr += "(";
                    key[0].forEach(element => {
                        outPutStr += toneStr[element];
                    });
                    outPutStr += ")";
                } else {
                    outPutStr += toneStr[key[0][0]];
                }
                if (key[1] >= gapTime) outPutStr += " ";
            });
            //Export to the file
            let baseName = "Music score export";
            let path = musicDir + baseName + ".txt";
            let i = 1;
            while (files.exists(path)) {
                console.log("Path " + path + " Already exists");
                path = musicDir + baseName + "(" + i.toString() + ")" + ".txt";
                i++;
            }
            files.write(path, outPutStr);
            dialogs.alert("Export successfully", "Exported to" + path);
            console.log("Export successfully: " + path);
            break;
        case ScoreExportType.keySequenceJSON:
            let baseName2 = "dump";
            let path2 = musicDir + baseName2 + ".json";
            let i2 = 1;
            while (files.exists(path2)) {
                console.log("Path " + path2 + " Already exists");
                path2 = musicDir + baseName2 + "(" + i2.toString() + ")" + ".json";
                i2++;
            }
            files.write(path2, JSON.stringify(noteData));
            dialogs.alert("Export successfully", "Exported to" + path2);
            console.log("Export successfully: " + path2);
            break;
        default:
            dialogs.alert("Export failed", "Unknown export type");
    }
}


/**
 * @param {number} timeSec
 */
function sec2timeStr(timeSec) {
    let minuteStr = Math.floor(timeSec / 60).toString();
    let secondStr = Math.floor(timeSec % 60).toString();
    if (minuteStr.length == 1) minuteStr = "0" + minuteStr;
    if (secondStr.length == 1) secondStr = "0" + secondStr;

    return minuteStr + ":" + secondStr;
}


function saveUserGameProfile() {
    let keyLocators = gameProfile.getKeyLocators();
    setGlobalConfig("keyLocators2", keyLocators);

    
    console.log("keyLocators2: " + JSON.stringify(keyLocators));
    console.log("Save the user's game configuration successfully");
    toast("Save the user's game configuration successfully");
}

function debugDump(obj, name) {
    console.log("====================" + name + "====================");
    console.log("Type of " + name + ": " + Object.prototype.toString.call(obj));
    let tmp = JSON.stringify(obj);
    console.log(tmp);
    console.log("====================" + name + "====================");
}

function importFileFromFileChooser() {
    let fileChooser = new FileChooser();
    // let filePath = fileChooser.chooseFileSync();
    // if (filePath == null) {
    //     toast("No file selected");
    //     console.warn("No file selected");
    //     return;
    // }
    // let isMusicFile = musicFormats.isMusicFile(filePath);
    // if (!isMusicFile) {
    //     toast("It's not a music file");
    //     console.warn(filePath + " It's not a music file");
    //     return;
    // }
    // //Copy the file to the music directory
    // let res = files.copy(filePath, musicDir + files.getName(filePath));
    // if (res) {
    //     toast("Successful import");
    //     console.log(filePath + " -> " + musicDir + files.getName(filePath));
    // } else {
    //     console.warn("Import failed");
    //     toast("Import failed");
    // }
    fileChooser.chooseFileAndCopyTo(musicDir);
}

function selectTracksInteractive(tracksData, lastSelectedTracksNonEmpty) {
    //Delete audio tracks without notes
    for (let i = tracksData.tracks.length - 1; i >= 0; i--) {
        if (tracksData.tracks[i].noteCount == 0) {
            tracksData.tracks.splice(i, 1);
        }
    }
    let nonEmptyTrackCount = tracksData.tracks.length;
    if (nonEmptyTrackCount === 1) {
        dialogs.alert("Prompt", "There is only one audio track, no need to choose.");
        return [0];
    }

    if (typeof (lastSelectedTracksNonEmpty) == "undefined" || lastSelectedTracksNonEmpty.length === 0) {
        lastSelectedTracksNonEmpty = [];
        for (let i = 0; i < nonEmptyTrackCount; i++) {
            lastSelectedTracksNonEmpty.push(i); //Select all audio tracks by default
        }
    }
    let trackInfoStrs = [];
    for (let i = 0; i < nonEmptyTrackCount; i++) {
        let track = tracksData.tracks[i];
        let avgPitch = 0;
        for (let j = 0; j < track.notes.length; j++) {
            avgPitch += track.notes[j][0];
        }
        avgPitch /= track.notes.length;
        let str = track.name + " (" + track.noteCount + "Notes, average pitch" + avgPitch.toFixed(1);
        if (track.notes[i][2].velocity != null) {
            let avgVelocity = 0;
            for (let j = 0; j < track.notes.length; j++) {
                avgVelocity += track.notes[j][2].velocity;
            }
            avgVelocity /= track.notes.length;
            avgVelocity *= 100;
            str += ", Strength" + avgVelocity.toFixed(0) + "%";
        }
        str += ")";
        trackInfoStrs.push(str);

    }
    let selectedTracksNonEmpty = /** @type {Number[]} */ (dialogs.multiChoice("Select the audio track", trackInfoStrs, lastSelectedTracksNonEmpty));
    if (selectedTracksNonEmpty.length == 0) { //Cancel the selection and keep it as it is
        selectedTracksNonEmpty = lastSelectedTracksNonEmpty;
    }
    return selectedTracksNonEmpty;
}

/**
 * @param {noteUtils.Note[]} noteData
 * @param {number} targetMajorPitchOffset
 * @param {number} targetMinorPitchOffset
 * @param {GameProfile} gameProfile
 * @brief Test the configuration effect 
 * @return {{
* "outRangedNoteWeight": number,
* "overFlowedNoteCnt": number,
* "underFlowedNoteCnt": number,
* "roundedNoteCnt": number,
* "totalNoteCnt": number,
* }}
*/
function evalFileConfig(noteData, targetMajorPitchOffset, targetMinorPitchOffset, gameProfile) {
    //The cost of discarding high-tone notes is higher than the cost of discarding low-tone notes, so the power is high.
    const overFlowedNoteWeight = 5;

    const pass = new passes.SequentialPass({
        passes: [
            new passes.PitchOffsetPass({
                offset: targetMajorPitchOffset * 12 + targetMinorPitchOffset
            }),
            new passes.LegalizeTargetNoteRangePass({
                currentGameProfile: gameProfile,
                semiToneRoundingMode: passes.SemiToneRoundingMode.floor
            })
        ]
    });
    let data = JSON.parse(JSON.stringify(noteData));
    pass.run(data, (progress) => {});
    const stats = pass.getStatistics();

    return {
        "outRangedNoteWeight": stats.LegalizeTargetNoteRangePass.overFlowedNoteCnt * overFlowedNoteWeight + stats.LegalizeTargetNoteRangePass.underFlowedNoteCnt,
        "overFlowedNoteCnt": stats.LegalizeTargetNoteRangePass.overFlowedNoteCnt,
        "underFlowedNoteCnt": stats.LegalizeTargetNoteRangePass.underFlowedNoteCnt,
        "roundedNoteCnt": stats.LegalizeTargetNoteRangePass.roundedNoteCnt,
        "totalNoteCnt": noteData.length,
    };
}

/**
 * @brief Automatically adjust the file configuration, including transposition and audio track selection
 * @param {string} fileName 
 * @param {number} trackDisableThreshold If a note in an audio track that exceeds this proportion is discarded, the track will not be selected.
 * @returns 
 */
function autoTuneFileConfig(fileName, trackDisableThreshold) {
    //Floating window prompts
    let dial = dialogs.build({
        title: "调整中...",
        content: "Adjusting the pitch offset, please wait...",
        progress: {
            max: 100,
            showMinMax: true
        },
    });
    dial.show();

    const tracksData = new passes.SequentialPass({
        passes: [
            new passes.ParseSourceFilePass({}),
            new passes.RemoveEmptyTracksPass({}),
        ]
    }).run(musicDir + fileProvider.loadMusicFile(fileName));
    
    const noteData = new passes.MergeTracksPass({}).run(tracksData);
    const inferBestPitchOffsetPass = new passes.InferBestPitchOffsetPass({
        gameProfile: gameProfile
    });
    inferBestPitchOffsetPass.run(noteData, (progress) => dial.setProgress(progress));
    const stats = inferBestPitchOffsetPass.getStatistics();

    console.info("The best octave offset: " + stats.bestOctaveOffset);
    console.info("The best semitone offset: " + stats.bestSemiToneOffset);

    //Disable audio tracks with too many invalid notes
    let selectedTracksNonEmpty = new Array();
    if (tracksData.haveMultipleTrack) {
        let trackPlayableNoteRatio = new Array();
        for (let i = 0; i < tracksData.trackCount; i++) {
            let track = tracksData.tracks[i];
            let playableNoteCnt = 0;
            let result = evalFileConfig(track.notes, stats.bestOctaveOffset, stats.bestSemiToneOffset, gameProfile);
            playableNoteCnt = track.notes.length - result.overFlowedNoteCnt - result.underFlowedNoteCnt;
            trackPlayableNoteRatio.push([i, playableNoteCnt / track.notes.length]);
        }
        trackPlayableNoteRatio.sort((a, b) => {
            return b[1] - a[1]; //Sort from large to small
        });
        console.log("The note ratio of the audio track can be used.: " + JSON.stringify(trackPlayableNoteRatio));
        selectedTracksNonEmpty = new Array();
        selectedTracksNonEmpty.push(trackPlayableNoteRatio[0][0]);
        trackPlayableNoteRatio.shift();
        for (let i = 0; i < trackPlayableNoteRatio.length; i++) {
            let obj = trackPlayableNoteRatio[i];
            if (obj[1] > trackDisableThreshold) {
                selectedTracksNonEmpty.push(obj[0]);
            }
        }
        console.info("Selected audio tracks: " + JSON.stringify(selectedTracksNonEmpty));
    }
    dial.dismiss();
    let realBestOutRangedNoteCnt = stats.bestOverFlowedNoteCnt + stats.bestUnderFlowedNoteCnt;
    let totalNoteCnt = noteData.length;
    /**
     * example: 
     * The best result:
     * The number of notes discarded beyond the range: 123 (+10, -113)(12.34%)
     * The number of notes that have been taken as a whole: 456 (56.78%)
     * The best octave offset: 0
     * The best semitone offset: 0
     */
    let percentStr1 = (realBestOutRangedNoteCnt / totalNoteCnt * 100).toFixed(2) + "%";
    let percentStr2 = (stats.bestRoundedNoteCnt / totalNoteCnt * 100).toFixed(2) + "%";
    let resultStr = "The best result: \n" +
        "The number of notes discarded beyond the range: " + realBestOutRangedNoteCnt + " (+" + stats.bestOverFlowedNoteCnt + ", -" + stats.bestUnderFlowedNoteCnt + ")(" + percentStr1 + ")\n" +
        "The number of notes that have been taken as a whole: " + stats.bestRoundedNoteCnt + " (" + percentStr2 + ")\n" +
        "The best octave offset: " + stats.bestOctaveOffset + "\n" +
        "The best semitone offset: " + stats.bestSemiToneOffset;
    if (tracksData.haveMultipleTrack)
        resultStr += "\nSelected track: " + JSON.stringify(selectedTracksNonEmpty);

    dialogs.alert("Adjust the result", resultStr);

    configuration.setFileConfigForTarget("majorPitchOffset", stats.bestOctaveOffset, fileName, gameProfile);
    configuration.setFileConfigForTarget("minorPitchOffset", stats.bestSemiToneOffset, fileName, gameProfile);
    configuration.setFileConfigForTarget("lastSelectedTracksNonEmpty", selectedTracksNonEmpty, fileName, gameProfile);
    toast("Automatic adjustment is completed");
    return 0;
}

/**
 * Pre-analysis documents
 */
function preAnalyzeFile(fileName){
    if (configuration.readFileConfigForTarget("lastAnalyzedFileTimestamp", fileName, gameProfile) != null) { //TODO: You should check the time stamp here. Let's talk about it later.
        return;
    }
    
    //Floating window prompts
    let dial = dialogs.build({
        title: "Initialize...",
        content: "The file is being analyzed, please wait....",
        progress: {
            max: 100,
            showMinMax: true
        },
    });
    dial.show();

    const tracksData = new passes.SequentialPass({
        passes: [
            new passes.ParseSourceFilePass({}),
            new passes.RemoveEmptyTracksPass({}),
        ]
    }).run(musicDir + fileProvider.loadMusicFile(fileName));

    const noteData = new passes.MergeTracksPass({}).run(tracksData);
    const inferBestPitchOffsetPass = new passes.InferBestPitchOffsetPass({
        gameProfile: gameProfile
    });
    inferBestPitchOffsetPass.run(noteData, (progress) => dial.setProgress(progress));
    const stats = inferBestPitchOffsetPass.getStatistics();
    console.info("The best octave offset: " + stats.bestOctaveOffset);
    console.info("The best semitone offset: " + stats.bestSemiToneOffset);
    //Save the analysis results
    configuration.setFileConfigForTarget("lastAnalyzedFileTimestamp", 1, fileName, gameProfile);
    configuration.setFileConfigForTarget("analyzedMajorPitchOffset", stats.bestOctaveOffset, fileName, gameProfile);
    configuration.setFileConfigForTarget("analyzedMinorPitchOffset", stats.bestSemiToneOffset, fileName, gameProfile);
    //If it has not been set before, it will also be set to the default value.
    if (configuration.readFileConfigForTarget("majorPitchOffset", fileName, gameProfile) == undefined) {
        configuration.setFileConfigForTarget("majorPitchOffset", stats.bestOctaveOffset, fileName, gameProfile);
    }
    if (configuration.readFileConfigForTarget("minorPitchOffset", fileName, gameProfile) == undefined) {
        configuration.setFileConfigForTarget("minorPitchOffset", stats.bestSemiToneOffset, fileName, gameProfile);
    }
    dial.dismiss();
}

function runClickPosSetup() {
    let pos = calibrateLayout("Please drag the positioning point to adjust the button position.", 
        gameProfile.getNormalizedKeyPositions()
    );

    if (pos == null) {
        toast("Calibration cancellation");
        return;
    }

    console.log("Custom coordinates: top left[" + pos[0][0] + "," + pos[0][1] + "],右下[" + pos[1][0] + "," + pos[1][1] + "]");

    gameProfile.setKeyPosition([pos[0][0], pos[0][1]], [pos[1][0], pos[1][1]]);
    saveUserGameProfile();
}

/**
 * @param {string | null} fullFileName
 * @param {(isAnythingChanged:boolean)=>void} onFinish
 * @param {Array<ConfigurationFlags>} [extFlags]
 */
function runFileConfigSetup(fullFileName, onFinish, extFlags){
    /**
     * @type {Dialogs.JsDialog?}
     */
    let dialog = null;
    let flags = [];
    if (extFlags != null) {
        flags = flags.concat(extFlags);
    }
    let fileName = null,rawFileName = null;
    if (fullFileName != null) {
        fileName = fullFileName;
        rawFileName = musicFormats.getFileNameWithoutExtension(fileName);
        let format = musicFormats.getFileFormat(fileName);

        if (format.haveDurationInfo) {
            flags.push(ConfigurationFlags.MUSIC_HAS_DURATION_INFO);
        }
        if (format.haveTracks) {
            flags.push(ConfigurationFlags.MUSIC_HAS_TRACKS);
        }
    }

    if (!flags.includes(ConfigurationFlags.WORKMODE_MIDI_INPUT_STREAMING)) {
        let playerSelection = configuration.readGlobalConfig("playerSelection", ["AutoJsGesturePlayer"]);
        if (playerSelection.includes("AutoJsGesturePlayer")) {
            flags.push(ConfigurationFlags.WORKMODE_GESTURE_PLAYER);
        }
        if (playerSelection.includes("SimpleInstructPlayer") || playerSelection.includes("SkyCotlLikeInstructPlayer")) {
            flags.push(ConfigurationFlags.WORKMODE_INSTRUCT);
        }
    }

    function showConfigDialog() {
        function refreshConfigUi() {
            if (dialog != null) {
                dialog.dismiss();
                dialog = null;
            }
            onFinish(configUi.isAnythingChanged());
            showConfigDialog();
        }
        let configUi = new ConfigurationUi(rawFileName, gameProfile, flags, (cmd, arg) => {
            console.info(`${cmd} : ${JSON.stringify(arg)}`);
            switch (cmd) {
                case "refreshConfigurationUi":
                    refreshConfigUi();
                    break;
                case "runAutoTune":
                    autoTuneFileConfig(fileName, arg.trackDisableThreshold);
                    refreshConfigUi();
                    break;
                case "selectTracks":
                    //This is the main thread, which can be blocked.
                    let dialog = dialogs.build({
                        title: "Loading...",
                        content: "Loading data...",
                    }).show();
                    let tracksData = new passes.ParseSourceFilePass({})
                        .run(musicDir + fileProvider.loadMusicFile(fileName));
                    dialog.dismiss();
                    let lastSelectedTracksNonEmpty = configuration.readFileConfigForTarget("lastSelectedTracksNonEmpty", rawFileName, gameProfile);
                    let result = selectTracksInteractive(tracksData, lastSelectedTracksNonEmpty);
                    configuration.setFileConfigForTarget("lastSelectedTracksNonEmpty", result, rawFileName, gameProfile);
                    break;
            }
        });
        let view = configUi.getView();
        dialog = dialogs.build({
            customView: view,
            title: "配置...",
            neutral: "完成",
        }).on("show", (dialog) => {
        }).on("neutral", (dialog) => {
            dialog.dismiss();
            onFinish(configUi.isAnythingChanged());
        }).show();
    }
    showConfigDialog();

    return;
}

/**
 * @brief Display the file selector
 * @param {FileProvider} fileProvider
 * @param {(selectedMusic: string?, selectedPlaylist: string?) => void} callback Callback function, the parameters are the selected file name and song list name
 */
function runFileSelector(fileProvider, callback) {
    fileProvider.refreshAllMusicFilesListCache();
    let fileSelector = new FileSelector(fileProvider);
    fileSelector.setOnItemSelected(callback);
    fileSelector.show();
    return;
}


function getTargetTriple() {
    let configName = gameProfile.getCurrentConfigDisplayName();
    let variantName = gameProfile.getCurrentVariantDisplayName();
    let keyTypeName = gameProfile.getCurrentKeyLayoutDisplayName();
    return configName + " " + variantName + " " + keyTypeName;
}

/**
 * @brief Calibrate the offset of the full-screen canvas
 * @param {string} [prompt] Prompt text, default: "Click anywhere to continue..."
 * @returns {[number, number]} Return the offset
 */
function calibrateFullScreenCanvasOffset(prompt){
    let promptText = "Click anywhere to continue...";
    if (prompt != null) {
        promptText = prompt;
    }
    let finish = false;
    let offset = [0,0];
    const fullScreenWindow = floaty.rawWindow(<canvas id="canv" w="*" h="*" />);
    fullScreenWindow.setTouchable(true);
    fullScreenWindow.setSize(-1, -1);
    fullScreenWindow.canv.setOnTouchListener(function (v, evt) {
        if (evt.getAction() == evt.ACTION_DOWN) {
            finish = true;
            const screenPos = [parseInt(evt.getRawX().toFixed(0)), parseInt(evt.getRawY().toFixed(0))];
            const windowPos = [parseInt(evt.getX().toFixed(0)), parseInt(evt.getY().toFixed(0))];
            offset = [screenPos[0] - windowPos[0], screenPos[1] - windowPos[1]];
        }
        return true;
    });
    fullScreenWindow.canv.on("draw", function (canvas) {
        while(finish) sleep(50);
        const Color = android.graphics.Color;
        const PorterDuff = android.graphics.PorterDuff;
        canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
        //Draw a gray background
        canvas.drawARGB(80, 0, 0, 0);
        //Draw the hint in the center
        const paint = new Paint();
        paint.setTextAlign(Paint.Align.CENTER);
        paint.setARGB(255, 255, 255, 255);
        paint.setTextSize(50);
        canvas.drawText(promptText, canvas.getWidth() / 2, canvas.getHeight() / 2, paint);
    });
    while (!finish) {
        sleep(100);
    }
    sleep(100);
    fullScreenWindow.close();
    console.log("Offset: " + offset);
    //@ts-ignore
    return offset;
}

function Vibrator(){
    const vibrator = context.getSystemService(context.VIBRATOR_SERVICE);
    let effect = null;

    /**
     * Set the vibration mode
     * @param {number} mode Pattern
     */
    this.setMode = function(mode){
        switch(mode){
            case 0:
                effect = null;
                break;
            case 1:
                effect = android.os.VibrationEffect.createPredefined(android.os.VibrationEffect.EFFECT_TICK);
                break;
            case 2:
                effect = android.os.VibrationEffect.createPredefined(android.os.VibrationEffect.EFFECT_CLICK);
                break;
            case 3:
                effect = android.os.VibrationEffect.createPredefined(android.os.VibrationEffect.EFFECT_HEAVY_CLICK);
                break;
            default:    
                effect = null;
                break;
        }
    }

    /**
     * Trigger vibration
     */
    this.vibrate = function(){
        if(effect != null){
            vibrator.vibrate(effect);
        }
    }
}



/////////
//Main program//
/////////
function initialize() {
    files.ensureDir(musicDir);
    //globalConfig.put("inited", 0);
    let currentRuntime = runtimes.getCurrentRuntime();
    switch (currentRuntime) {
        case runtimes.Runtime.AUTOJS6:
            console.info("Current operating environment: AutoJs6");
            break;
        case runtimes.Runtime.AUTOXJS:
            console.info("Current operating environment: AutoX.js");
            break;
        default:
            console.warn("Current operating environment: not supported or unknown!");
            break;
    }
    if (readGlobalConfig("lastVersion", 0) != scriptVersion) {
        //Start for the first time, initialize settings
        toast("Initialize settings..");

        if (readGlobalConfig("skipInit", -1) == -1) setGlobalConfig("skipInit", true);
        if (readGlobalConfig("skipBlank5s", -1) == -1) setGlobalConfig("skipBlank5s", false);
        if (readGlobalConfig("waitForGame", -1) == -1) setGlobalConfig("waitForGame", true);
        setGlobalConfig("userGameProfile", null);

        let files_ = files.listDir("./exampleTracks");
        for (let i in files_) {
            console.log("copy:" + files_[i]);
            files.copy("./exampleTracks/" + files_[i], musicDir + files_[i]);
        };
        setGlobalConfig("lastVersion", scriptVersion);
    };
    fileProvider.updateCloudMusicList();
}

function main() {
    let evt = events.emitter(threads.currentThread());
    /**
     * @type {String[]}
     */
    let totalFiles = [];
    const haveFloatyPermission = runtimes.getCurrentRuntime() === runtimes.Runtime.AUTOXJS ?
        floaty.checkPermission() :
        floaty.hasPermission();
    if (!haveFloatyPermission) {
        // There is no floating window permission, prompt the user and jump to the request.
        toastLog(`Please open the application. "${appName}" The floating window permission!`);
        floaty.requestPermission();
        while (!floaty.checkPermission());
        toastLog('The floating window permission has been turned on.');
    }

    let titleStr = "Current configuration: " + getTargetTriple();
    console.info(titleStr);

    //Enter the music data to the player. It may be a key list or a gesture list.
    let musicFileData = null;
    /**
     * @type {Number?}
     */
    let lastSelectedFileIndex = null;
    let progress = 0;
    let progressChanged = false;
    let totalTimeSec = null;
    let totalTimeStr = null;
    let currentGestureIndex = null;
    let visualizerWindow = null;
    let operationMode = ScriptOperationMode.NotRunning;
    let midiInputStreamingNoteCount = 0;
    let selectedPlayerTypes = [PlayerType.SimpleInstructPlayer];
    let midiInputStreamReloadSettings = false;
    /**
     * List of keys
     * @type {import("./src/noteUtils.js").PackedKey[]?}
     */
    let packedKeyListData = null;
    /**
     * @type {string?}
     */
    let currentLyricLine = null;
    /**
     * @type {Array<import("./src/players").PlayerBase>}
     */
    let selectedPlayers = [new AutoJsGesturePlayer()];
    let instructWindow = null;
    const vibrator = new Vibrator();

    //Display the floating window
    /**
     * @type {any}
     */
    let controlWindow = floaty.window(
        <card elevation="0dp" cornerRadius="12dp" margin="4dp" cardBackgroundColor="#CCFFFFFF" id="controlWindowFrame" visibility="gone">
            <frame background="#00FFFFFF" w="*" h="*">
                <vertical padding="8dp">
                    <horizontal marginBottom="4dp">                        
                        <text id="musicTitleText" text="No songs have been selected..." textColor="#333333" textSize="14sp" maxLines="1" ellipsize="end" layout_weight="1" />
                        <text id="timerText" text="00:00/00:00" textColor="#666666" textSize="12sp" marginLeft="4dp" />
                        <button id="hideBtn" style="Widget.AppCompat.Button.Borderless" w="20dp" h='20dp' text="—" textSize="14sp" margin="0dp" padding="0dp" />
                    </horizontal>
                    
                    <seekbar id="progressBar" style="@style/Widget.AppCompat.SeekBar" layout_width="match_parent" layout_height="wrap_content" progressTint="#4CAF50" thumbTint="#4CAF50" />
                    
                    <horizontal gravity="center" marginTop="4dp">
                        <button id="fileSelectionMenuBtn" style="Widget.AppCompat.Button.Borderless" w="28dp" h='28dp' text="📁" textSize="18sp" margin="0dp" padding="0dp" />
                        <button id="currentFileConfigBtn" style="Widget.AppCompat.Button.Borderless" w="28dp" h='28dp' text="🎹" textSize="18sp" margin="0dp" padding="0dp" />
                        <button id="prevBtn" style="Widget.AppCompat.Button.Borderless" w="28dp" h='28dp' text="⏮" textSize="18sp" margin="0dp" padding="0dp" />
                        <button id="pauseResumeBtn" style="Widget.AppCompat.Button.Borderless" w="28dp" h='28dp' text="▶️" textSize="18sp" margin="0dp" padding="0dp" />
                        <button id="nextBtn" style="Widget.AppCompat.Button.Borderless" w="28dp" h='28dp' text="⏭" textSize="18sp" margin="0dp" padding="0dp" />
                        <button id="globalConfigBtn" style="Widget.AppCompat.Button.Borderless" w="28dp" h='28dp' text="⚙" textSize="18sp" margin="0dp" padding="0dp" />
                    </horizontal>
                </vertical>
            </frame>
        </card>
    );
    let controlWindowVisible = false;
    /**
     * @param {boolean} visible
     */
    function controlWindowSetVisibility(visible) {
        ui.run(() => {
            if (visible) {
                controlWindow.controlWindowFrame.setVisibility(android.view.View.VISIBLE);
            } else {
                controlWindow.controlWindowFrame.setVisibility(android.view.View.GONE);
            }
        });
    }

    ui.run(() => {
        controlWindow.musicTitleText.setText(titleStr);
        controlWindow.musicTitleText.setSelected(true);
    });

    controlWindow.fileSelectionMenuBtn.click(() => {
        evt.emit("fileSelectionMenuBtnClick");
    });
    controlWindow.currentFileConfigBtn.click(() => {
        evt.emit("currentFileConfigBtnClick");
    });
    controlWindow.prevBtn.click(() => {
        if (lastSelectedFileIndex == null) return;
        if (lastSelectedFileIndex > 0) lastSelectedFileIndex--;
        evt.emit("fileSelect");
    });
    controlWindow.nextBtn.click(() => {
        if (lastSelectedFileIndex == null) return;
        if (lastSelectedFileIndex < totalFiles.length - 1) lastSelectedFileIndex++;
        evt.emit("fileSelect");
    });

    controlWindow.pauseResumeBtn.click(() => {
        evt.emit("pauseResumeBtnClick");
    });

    controlWindow.progressBar.setOnSeekBarChangeListener({
        onProgressChanged: function (seekBar, progress0, fromUser) {
            if (fromUser) {
                progress = progress0;
                progressChanged = true;
            };
        }
    });
    controlWindow.globalConfigBtn.click(() => { evt.emit("globalConfigBtnClick"); });
    controlWindow.hideBtn.click(() => {
        evt.emit("hideBtnClick");
    });
    controlWindow.pauseResumeBtn.setOnLongClickListener(() => {
        evt.emit("pauseResumeBtnLongClick");
        return true;
    });
    controlWindow.musicTitleText.click(() => {
        evt.emit("musicTitleTextClick");
    });

    toast("Click the time to adjust the position of the floating window.");

    //Floating window position/size adjustment
    let controlWindowPosition = readGlobalConfig("controlWindowPosition", [device.width / 3, 0]);
    //Avoid the floating window being blocked by the screen frame.
    controlWindow.setPosition(controlWindowPosition[0], controlWindowPosition[1]);
    let controlWindowSize = readGlobalConfig("controlWindowSize", [Math.max(device.width, device.height) * 2 / 5, -2]);
    controlWindow.setSize(controlWindowSize[0], controlWindowSize[1]);
    //controlWindow.setTouchable(true);

    let controlWindowLastClickTime = 0;
    //Floating window incident
    controlWindow.timerText.on("click", () => {
        let now = new Date().getTime();
        if (now - controlWindowLastClickTime < 500) {
            toast("Reset the size and position of the floating window");
            controlWindow.setSize(device.width / 2, -2);
            controlWindow.setPosition(device.width / 3, 40);
        }
        controlWindowLastClickTime = now;

        let adjEnabled = controlWindow.isAdjustEnabled();
        controlWindow.setAdjustEnabled(!adjEnabled);

        //Memory position
        if (adjEnabled) {
            controlWindow.setSize(controlWindow.getWidth(), controlWindow.getHeight());
            setGlobalConfig("controlWindowPosition", [controlWindow.getX(), controlWindow.getY()]);
            setGlobalConfig("controlWindowSize", [controlWindow.getWidth(), -2]);
        }
    });

    let visualizerWindowRequestClose = false;

    //Visual floating window
    const createVisualizerWindow = function () {
        let visualizerWindow = floaty.window(
            <canvas id="canv" w="*" h="*" />
        );
        let visualizerWindowPosition = readGlobalConfig("visualizerWindowPosition", [100, 100]);
        visualizerWindow.setPosition(visualizerWindowPosition[0], visualizerWindowPosition[1]);
        let visualizerWindowSize = readGlobalConfig("visualizerWindowSize", [device.width / 2, device.height / 2]);
        visualizerWindow.setSize(visualizerWindowSize[0], visualizerWindowSize[1]);
        visualizerWindow.canv.on("draw", function (canvas) {
            visualizer.draw(canvas);
            //If the window is closed during drawing, the app will crash directly, so wait here. 
            if (visualizerWindowRequestClose) {
                sleep(1000);
            }
        });
        //The time of the last click
        let visualizerLastClickTime = 0;

        //Touch event (here on("click",...) It failed again. The documents of AutoXjs are really bad)
        visualizerWindow.canv.click(function () {
            let now = new Date().getTime();
            if (now - visualizerLastClickTime < 500) {
                toast("Reset the size and position of the floating window");
                visualizerWindow.setSize(device.width * 2 / 3, device.height * 2 / 3);
                visualizerWindow.setPosition(100, 100);
            }
            visualizerLastClickTime = now;
            let adjEnabled = visualizerWindow.isAdjustEnabled();
            visualizerWindow.setAdjustEnabled(!adjEnabled);
            if (adjEnabled) {
                //Update the size (when zooming with the drag handle on the window, the size of the window will not actually change, so it needs to be updated manually here)
                visualizerWindow.setSize(visualizerWindow.getWidth(), visualizerWindow.getHeight());
                //Save the current location and size
                setGlobalConfig("visualizerWindowPosition", [visualizerWindow.getX(), visualizerWindow.getY()]);
                setGlobalConfig("visualizerWindowSize", [visualizerWindow.getWidth(), visualizerWindow.getHeight()]);
            }
        });
        return visualizerWindow;
    }

    function visualizerWindowClose() {
        if (visualizerWindow == null) return;
        visualizerWindowRequestClose = true;
        sleep(200);
        visualizerWindow.close();
        visualizerWindowRequestClose = false;
    }

    function exitApp() {
        visualizerWindowClose();
        if(instructWindow != null) instructWindow.close();
        controlWindow.close();
        threads.shutDownAll();
        exit();
    }

    //Main function, processing events and updating progress
    evt.on("pauseResumeBtnClick", () => {
        for (let player of selectedPlayers) {
            if (player.getState() == player.PlayerStates.PAUSED) {
                if (player.getType() === PlayerType.AutoJsGesturePlayer && !checkEnableAccessbility()) return;
                player.resume();
            } else if (player.getState() == player.PlayerStates.PLAYING) {
                player.pause();
            } else if (player.getState() == player.PlayerStates.FINISHED) {
                if (player.getType() === PlayerType.AutoJsGesturePlayer && !checkEnableAccessbility()) return;
                player.seekTo(0);
                player.resume();
            }
        }
    });

    evt.on("fileSelect", () => {
        for (let player of selectedPlayers) {
            player.stop();
        }
        if (visualizerWindow != null) {
            visualizerWindowClose();
            visualizerWindow = null;
        }
        let fileName = totalFiles[lastSelectedFileIndex];
        gameProfile.clearCurrentConfigCache();
        //If it is a cloud file, you need to download it first.
        if (fileName.startsWith("cloud:") && fileProvider.loadCloudMusicFileFromTmp(fileName) == null) {
            const d = dialogs.build({
                title: "Loading...",
                content: "Loading cloud music files...",
                progress: {
                    max: -1,
                    horizontal: true
                }
            });
            d.show();
            fileProvider.loadCloudMusicFile(fileName, (err, succeed) => {
                d.dismiss();
                if (err) {
                    dialogs.alert("Loading failed", "Failed to load cloud music files: " + err);
                    return;
                }
                evt.emit("fileSelect");
            });
            return;
        }
        preAnalyzeFile(fileName);
        // //If it is running for the first time, the setting wizard will be displayed.
        // if (!haveFileConfig(musicFormats.getFileNameWithoutExtension(fileName))) {
        //     let res = dialogs.confirm("Setting Wizard", "Detected that you are playing this song for the first time, do you want to run the settings?");
        //     if (res) {
        //         runFileConfigSetup(fileName, (anythingChanged) => {
        //             evt.emit("fileSelect");
        //         });
        //         return null;
        //     };
        // };
        let data = null;
        try {
            //Choose a player
            selectedPlayerTypes = readGlobalConfig("playerSelection", ["AutoJsGesturePlayer"]);

            switch (selectedPlayerTypes[0]) { //FIXME: At present, only a single player is supported.
                case PlayerType.AutoJsGesturePlayer:
                    data = loadMusicFile(fileName, MusicLoaderDataType.GestureSequence);
                    break;
                case PlayerType.SimpleInstructPlayer:
                case PlayerType.SkyCotlLikeInstructPlayer:
                    data = loadMusicFile(fileName, MusicLoaderDataType.KeySequence);
                    break;
                default:
                    throw new Error("未知的播放器类型: " + selectedPlayerTypes);
                    break;
            }
        } catch (e) {
            console.error(`Failed to load the music file: ${e}`);
            let res = dialogs.confirm("Loading failed!", `Failed to load the music file, which may be due to damage to the file, configuration error or script bug.\nClick "OK" to reset the configuration of this song, which can sometimes solve the problem.\nYou can also feedback the following error message to the developer (the screenshot is at the top part):\n\n${e}\n${e.stack}`);
            if (res) {
                configuration.clearFileConfig(fileName);
            }
            return;
        }
        if (data == null) {
            console.error("加载乐曲文件失败, data == null");
            return;
        }
        //Load the visualization window
        const layout = gameProfile.getCurrentKeyLayout()
        if(layout.row != null && layout.column != null){
            visualizer.setKeyLayout(layout.row, layout.column);
            visualizer.loadNoteData(data.packedKeyList);
            visualizer.goto(-1);
        }

        musicFileData = data.gestureList != null ? data.gestureList : data.packedKeyList;
        packedKeyListData = data.packedKeyList;
        totalTimeSec = musicFileData[musicFileData.length - 1][1] / 1000;
        totalTimeStr = sec2timeStr(totalTimeSec);
        progress = 0;
        progressChanged = true;
        currentGestureIndex = null;
        evt.emit("fileLoaded");
    });
    evt.on("currentFileConfigBtnClick", () => {
        if (lastSelectedFileIndex == null && operationMode != ScriptOperationMode.MIDIInputStreaming) {
            toast("Please select the song or start MIDI streaming first.");
            return;
        }
        for (let player of selectedPlayers)
            player.pause();

        if (operationMode == ScriptOperationMode.MIDIInputStreaming) {
            runFileConfigSetup(null, (res) => {
                if (res) {
                    midiInputStreamReloadSettings = true;
                }
            }, [ConfigurationFlags.WORKMODE_MIDI_INPUT_STREAMING]);
            return;
        } else {
            let fileName = totalFiles[lastSelectedFileIndex];
            runFileConfigSetup(fileName, (res) => {
                if (res) { //The settings have changed.
                    evt.emit("fileSelect");
                }
            });
        }
    });
    evt.on("globalConfigBtnClick", () => {
        for (let player of selectedPlayers)
            player.pause();
        switch (dialogs.select("Other options...",
            ["🎮Choose games/musical instruments",
                "📍Set the coordinates",
                "📃 Check the usage help",
                "📲 MIDIStreaming performance",
                "🎼 Export the current song",])) {
            case -1:
                break;
            case 0:
                //Target game
                let configList = gameProfile.getConfigNameList();
                let sel = /** @type {Number} */ (dialogs.select("Select the target game...", configList));
                if (sel == -1) {
                    toastLog("The settings have not changed.");
                    break;
                }
                let configName = configList[sel];
                setGlobalConfig("activeConfigName", configName);
                setGlobalConfig("lastConfigName", configName);
                gameProfile.setConfigByName(configName);
                console.log("The target game has been set to: " + configName);
                //Target musical instrument
                let instrumentList = gameProfile.getCurrentAvailableVariants();
                if (instrumentList == null || instrumentList.length == 0) {
                    throw new Error("There are no instruments available in the current game.!");
                } else if (instrumentList.length == 1) {
                    gameProfile.setCurrentVariantDefault();
                    setGlobalConfig("lastVariantName", gameProfile.getCurrentVariantTypeName());
                } else {
                    let nameList = instrumentList.map((variant) => variant.variantName);
                    let sel = /** @type {Number} */ (dialogs.select("Select the target instrument...", nameList));
                    if (sel == -1) {
                        toastLog("The settings have not changed.");
                        break;
                    }
                    let typeName = instrumentList[sel].variantType;
                    gameProfile.setCurrentVariantByTypeName(typeName);
                    setGlobalConfig("lastVariantName", typeName);
                    console.log("The target instrument has been set to: " + typeName);
                }
                //Target key position
                let keyLayoutList = gameProfile.getCurrentAvailableKeyLayouts();
                if (keyLayoutList == null || keyLayoutList.length == 0) {
                    throw new Error("There are no keys available in the current game!");
                } else if (keyLayoutList.length == 1) {
                    gameProfile.setCurrentKeyLayoutDefault();
                    setGlobalConfig("lastKeyTypeName", gameProfile.getCurrentKeyLayoutTypeName());
                } else {
                    let nameList = keyLayoutList.map((keyLayout) => keyLayout.displayName);
                    let sel = /** @type {Number} */ (dialogs.select("Select the target key position...", nameList));
                    if (sel == -1) {
                        toastLog("The settings have not changed.");
                        break;
                    }
                    let typeName = keyLayoutList[sel].name;
                    gameProfile.setCurrentKeyLayoutByTypeName(typeName);
                    setGlobalConfig("lastKeyTypeName", typeName);
                    console.log("The target key has been set to: " + typeName);
                }

                toastLog("The settings have been saved.");
                break;
            case 1: //Set the coordinates
                runClickPosSetup();
                break;
            case 2: //Check the usage help
                app.viewFile(musicDir + "Use help.pdf");
                exitApp();
                break;
            case 3: //MIDI streaming
                visualizerWindowClose();
                evt.emit("midiStreamStart");
                //exitApp();
                break;
            case 4: //Export the current song
                if (lastSelectedFileIndex == null) break;
                let fileName = totalFiles[lastSelectedFileIndex];
                gameProfile.clearCurrentConfigCache();
                let sel2 = dialogs.select("Export the current music...", ["Export as txt keyboard score", "Export as JSON key sequence data"]);
                let exportType = ScoreExportType.none;
                let loadDataType = MusicLoaderDataType.KeySequence;
                switch (sel2) {
                    case -1: break;
                    case 0: //txtKeyboard score
                        exportType = ScoreExportType.keyboardScore;
                        loadDataType = MusicLoaderDataType.KeySequenceHumanFriendly;
                        break;
                    case 1:
                        exportType = ScoreExportType.keySequenceJSON;
                        loadDataType = MusicLoaderDataType.KeySequence;
                        break;
                }
                let data = loadMusicFile(fileName, loadDataType);
                if (data == null) {
                    break;
                }
                exportNoteDataInteractive(data.packedKeyList, exportType);
        };
        titleStr = "Current configuration: " + getTargetTriple();
        ui.run(() => {
            controlWindow.musicTitleText.setText(titleStr);
        });
    });
    evt.on("fileSelectionMenuBtnClick", () =>
        runFileSelector(fileProvider, (music, playlist) => {
            if (playlist == null) {
                totalFiles = fileProvider.listAllMusicFilesWithCache();
            } else {
                let res = fileProvider.listMusicInList(playlist);
                if (res == null || res.length == 0) {
                    totalFiles = [];
                    return;
                }
                totalFiles = res;
            }
            if(music == null){
                lastSelectedFileIndex = null;
                return;
            }
            lastSelectedFileIndex = totalFiles.indexOf(music);
            evt.emit("fileSelect");
        })
    );
    evt.on("midiStreamStart", () => {
        if(!checkEnableAccessbility()) return;
        const stream = setupMidiStream();
        if (stream == null) {
            toast("MIDI streaming failed to start");
            return;
        }
        toast("MIDI streaming has been started.");
        selectedPlayers = [];
        selectedPlayers.push(new AutoJsGesturePlayer());
        operationMode = ScriptOperationMode.MIDIInputStreaming;
        ui.run(() => {
            controlWindow.musicTitleText.setText("MIDI streaming...");
        });
        midiInputStreamingNoteCount = 0;
        midiInputStreamReloadSettings = true;
        let octaveOffset = 0;
        let semiToneOffset = 0;
        //"Pseudo-sustination", used to simulate the delay effect during streaming
        let fakeSustainInterval = 0;
        let pressedKeysList = new java.util.concurrent.CopyOnWriteArrayList(); //Thread security
        const keyCount = gameProfile.getAllKeyPositions().length;
        for (let i = 0; i < keyCount; i++) {
            pressedKeysList.add(false);
        }
        const fakeSustainThread = threads.start(function () {
            while (true) {
                while(fakeSustainInterval == 0) sleep(500);
                let gestureList = new Array();
                for (let j = 0; j < keyCount; j++) { 
                    if(pressedKeysList.get(j).booleanValue()){  //Oh, Boolean on Java can't be used directly.
                        gestureList.push([0, 5, gameProfile.getKeyPosition(j)]);
                    }
                };
                if (gestureList.length > 10) gestureList.splice(9, gestureList.length - 10); //Only 10 gestures can be performed at the same time.
                if (gestureList.length != 0) {
                    for (let player of selectedPlayers)
                        player.exec(gestureList);
                };
                sleep(fakeSustainInterval * 0.8 + Math.random() * fakeSustainInterval * 0.4); //Change to normal distribution?
            }
        });

        stream.onDataReceived(function (datas) {
            const STATUS_COMMAND_MASK = 0xF0;
            const STATUS_CHANNEL_MASK = 0x0F;
            const STATUS_NOTE_OFF = 0x80;
            const STATUS_NOTE_ON = 0x90;

            if(midiInputStreamReloadSettings){
                midiInputStreamReloadSettings = false;
                octaveOffset = configuration.readGlobalConfig("MIDIInputStreaming_majorPitchOffset", 0);
                semiToneOffset = configuration.readGlobalConfig("MIDIInputStreaming_minorPitchOffset", 0);
                fakeSustainInterval = configuration.readGlobalConfig("MIDIInputStreaming_fakeSustainInterval", 0);
            }

            let keyList = new Array();
            for (let data of datas) {
                let cmd = data[0] & STATUS_COMMAND_MASK;
                if (cmd == STATUS_NOTE_ON && data[2] != 0) { // velocity != 0
                    let key = gameProfile.getKeyByPitch(data[1] + semiToneOffset + octaveOffset * 12);
                    if (key != -1 && keyList.indexOf(key) === -1){
                        keyList.push(key);
                        pressedKeysList.set(key, true);
                    }
                    midiInputStreamingNoteCount++;
                }else if (cmd == STATUS_NOTE_OFF || data[2] == 0) {
                    let key = gameProfile.getKeyByPitch(data[1] + semiToneOffset + octaveOffset * 12);
                    if (key != -1){
                        pressedKeysList.set(key, false);
                    }
                }
            }
            let gestureList = new Array();
            for (let j = 0; j < keyList.length; j++) { //Traverse this array
                let key = keyList[j];
                gestureList.push([0, 5, gameProfile.getKeyPosition(key)]);
            };
            if (gestureList.length > 10) gestureList.splice(9, gestureList.length - 10); //Only 10 gestures can be performed at the same time.

            if (gestureList.length != 0) {
                for (let player of selectedPlayers)
                    player.exec(gestureList);
            };

        });
        evt.on("hideBtnClick", () => {
            stream.close();
            controlWindowVisible = false;
            controlWindowSetVisibility(false);
            fakeSustainThread.interrupt();
        });
    });
    evt.on("pauseResumeBtnLongClick", () => {
        //Hide the floating window to play
        toast("Play in 8 seconds...");
        visualizerWindowClose();
        controlWindow.close();
        controlWindow = null;
        selectedPlayers[0].setOnStateChange(function (newState) {
            if (newState == selectedPlayers[0].PlayerStates.FINISHED) {
                exitApp();
            }
            console.warn("Unexpected state:" + newState);
        });
        setTimeout(() => {
            for (let player of selectedPlayers)
                player.resume();
        }, 8000);
    });
    evt.on("hideBtnClick", () => {
        controlWindowVisible = false;
        controlWindowSetVisibility(false);
    });
    evt.on("exitApp", () => {
        exitApp();
    });
    evt.on("fileLoaded", () => {
        operationMode = ScriptOperationMode.FilePlayer;
        if (instructWindow != null) {
            instructWindow.close();
            instructWindow = null;
        }
        selectedPlayers = [];
        let autoStartPlaying = false;
        switch (selectedPlayerTypes[0]) { //FIXME:
            case PlayerType.AutoJsGesturePlayer:
                selectedPlayers.push(new AutoJsGesturePlayer());
                console.log("new AutoJsGesturePlayer");
                break;
            case PlayerType.SimpleInstructPlayer:
            case PlayerType.SkyCotlLikeInstructPlayer:
                let impl = null;
                if (selectedPlayerTypes[0] == PlayerType.SkyCotlLikeInstructPlayer) {
                    selectedPlayers.push(new SkyCotlLikeInstructPlayer());
                    //@ts-ignore
                    impl = /** @type {import("./src/instruct.js").SkyCotlLikeInstructPlayerImpl} */ (selectedPlayers[0].getImplementationInstance());
                    impl.setDrawLineToEachNextKeys(
                        configuration.readGlobalConfig("SkyCotlLikeInstructPlayer_DrawLineToEachNextKeys", false)
                    );
                    impl.setDrawLineToNextNextKey(
                        configuration.readGlobalConfig("SkyCotlLikeInstructPlayer_DrawLineToNextNextKey", true)
                    );
                    impl.setDrawRingOutside(
                        configuration.readGlobalConfig("SkyCotlLikeInstructPlayer_DrawRingOutside", false)
                    );
                    let keyRange = gameProfile.getKeyRange();
                    keyRange = [keyRange[0] - 1, keyRange[1] - 1]; //Start from 0
                    let keyOrderMap = new Map();
                    for (let i = keyRange[0]; i <= keyRange[1]; i++) {
                        keyOrderMap.set(i, gameProfile.getPitchByKey(i));
                    }
                    impl.setKeyOrder(keyOrderMap);

                    console.log("new SkyCotlLikeInstructPlayer");
                }else if (selectedPlayerTypes[0] == PlayerType.SimpleInstructPlayer) {
                    selectedPlayers.push(new SimpleInstructPlayer());
                    impl = /** @type {import("./src/instruct.js").SimpleInstructPlayerImpl} */ (selectedPlayers[0].getImplementationInstance());
                    console.log("new SimpleInstructPlayer");
                }else{
                    throw new Error("Unknown player type: " + selectedPlayerTypes);
                }
                autoStartPlaying = true;
                const offset = calibrateFullScreenCanvasOffset();
                let keyPositions = JSON.parse(JSON.stringify(gameProfile.getAllKeyPositions()));
                for (let keyPos of keyPositions) {
                    keyPos[0] -= offset[0];
                    keyPos[1] -= offset[1];
                }
                impl.setKeyPositions(keyPositions);
                impl.setKeyRadius(gameProfile.getPhysicalMinKeyDistance() * 0.3 * configuration.readGlobalConfig("SimpleInstructPlayer_MarkSize", 1));
                //Create a full-screen floating window. Maybe it doesn't need full screen?
                instructWindow = floaty.rawWindow(<canvas id="canv" w="*" h="*" />);
                instructWindow.setTouchable(false);
                instructWindow.setSize(-1, -1);
                //Turn on hardware acceleration
                instructWindow.canv.setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null);
                let targetFps = context.getSystemService(Context.WINDOW_SERVICE).getDefaultDisplay().getRefreshRate();
                console.log(`目标FPS: ${targetFps} fps`);
                // instructWindow.canv.setMaxFps(fps);  //Bad
                let canvasClass = instructWindow.canv.getClass();
                let mTimePerDrawField = canvasClass.getDeclaredField("mTimePerDraw");
                mTimePerDrawField.setAccessible(true);
                mTimePerDrawField.set(instructWindow.canv, org.mozilla.javascript.Context.jsToJava(1000 / targetFps, java.lang.Long.TYPE));
                instructWindow.canv.on("draw", function (canvas) {
                    impl.draw(canvas);
                });
                //Set the vibration
                let instructVibrationEffect = configuration.readGlobalConfig("instructVibrationEffect", 1);
                vibrator.setMode(instructVibrationEffect);
                break;
            default:
                throw new Error("Unknown player type: " + selectedPlayerTypes);
                break;
        }
        selectedPlayers[0].setOnStateChange(function (newState) {
            if (newState == selectedPlayers[0].PlayerStates.PAUSED ||
                newState == selectedPlayers[0].PlayerStates.FINISHED) {
                controlWindow.pauseResumeBtn.setText("▶️");
            } else if (newState == selectedPlayers[0].PlayerStates.PLAYING) {
                controlWindow.pauseResumeBtn.setText("⏸");
            }
        });
        selectedPlayers[0].setOnPlayNote(function (note) {
            currentGestureIndex = note;
            note = Math.max(0, note - 1)
            visualizer.goto(note);
            if (packedKeyListData[note][2][0].lyric != null) {
                currentLyricLine = packedKeyListData[note][2][0].lyric;
            }
            if(instructWindow != null){
                vibrator.vibrate();
            }
        });
        ui.run(() => {
            controlWindow.musicTitleText.setText(
                musicFormats.getFileNameWithoutExtension(totalFiles[lastSelectedFileIndex]));
        });
        for (let player of selectedPlayers)
            player.setGestureTimeList(musicFileData);
        //Set the click position offset
        const clickPositionDeviationMm = readGlobalConfig("clickPositionDeviationMm", 1);
        const displayMetrics = context.getResources().getDisplayMetrics();
        const TypedValue = android.util.TypedValue;
        const clickPositionDeviationPx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_MM, clickPositionDeviationMm, displayMetrics);
        console.verbose(`Click the position offset: ${clickPositionDeviationPx} px`);
        for (let player of selectedPlayers)
            player.setClickPositionDeviationPx(clickPositionDeviationPx);
        //Whether to display the visualization window
        let visualizationEnabled = readGlobalConfig("visualizationEnabled", false);
        // if (visualizationEnabled && gameProfile.getKeyLayout().type === "grid") { //TODO: Other types of key layouts can also display visualization windows.
        //     visualizerWindow = createVisualizerWindow();
        //     toast("Click the visualization window to adjust the size and position, and double-click to reset");
        // };
        for (let player of selectedPlayers) {
            player.start();
            player.pause();
            if(autoStartPlaying)
                player.resume();
            currentGestureIndex = 0;
        }
    });

    evt.on("musicTitleTextClick", () => {
        if (packedKeyListData == null) return;
        let lyricLines = new Array();
        let indexes = new Array();
        for (let i = 0; i < packedKeyListData.length; i++) {
            //@ts-ignore
            let lyric = packedKeyListData[i][2][0].lyric;
            if (lyric != null) {
                lyricLines.push(lyric);
                indexes.push(i);
            }
        }
        if (lyricLines.length == 0) {
            toast("No lyrics were found.");
            return;
        }
        for (let player of selectedPlayers)
            player.pause();
        let sel = dialogs.select("Jump to the lyrics...", lyricLines);
        if (sel == -1) return;
        currentGestureIndex = indexes[sel];
        for (let player of selectedPlayers){
            player.seekTo(currentGestureIndex);
            player.resume();
        }
    });

    function controlWindowUpdateLoop() {
        if (controlWindow == null) {
            return;
        }
        switch (operationMode) {
            case ScriptOperationMode.NotRunning:
                break;
            case ScriptOperationMode.FilePlayer: {
                if (musicFileData == null || totalTimeSec == null || currentGestureIndex == null) break;
                //If the progress bar is dragged, update the playback progress.
                if (progressChanged) {
                    progressChanged = false;
                    let targetTimeSec = totalTimeSec * progress / 100;
                    for (let j = 0; j < musicFileData.length; j++) {
                        if (musicFileData[j][1] > targetTimeSec * 1000) {
                            currentGestureIndex = j - 1;
                            break;
                        }
                    }
                    currentGestureIndex = Math.max(0, currentGestureIndex);
                    for (let player of selectedPlayers)
                        player.seekTo(currentGestureIndex);
                    console.log("seekTo:" + currentGestureIndex);
                    setImmediate(controlWindowUpdateLoop);
                }
                currentGestureIndex = Math.min(currentGestureIndex, musicFileData.length - 1);
                //Calculate time
                let curTimeSec = musicFileData[currentGestureIndex][1] / 1000;
                let curTimeStr = sec2timeStr(curTimeSec);
                let timeStr = curTimeStr + "/" + totalTimeStr;
                //Update window
                ui.run(() => {
                    controlWindow.progressBar.setProgress(curTimeSec / totalTimeSec * 100);
                    controlWindow.timerText.setText(timeStr);
                    if(currentLyricLine != null){
                        controlWindow.musicTitleText.setText(currentLyricLine);
                        currentLyricLine = null;
                    }
                });
            }
                break;
            case ScriptOperationMode.MIDIInputStreaming:
                ui.run(() => {
                    controlWindow.timerText.setText(`音符数: ${midiInputStreamingNoteCount}`);
                });
                break;
        }
    }
    setInterval(controlWindowUpdateLoop, 200);

    //Floating button
    let fb = new FloatButton();
    fb.setIcon('@drawable/ic_library_music_black_48dp');
    fb.setTint('#ffff00');
    fb.setColor('#019581');
    fb.addItem('Hide/show the main floating window')
        .setIcon('@drawable/ic_visibility_black_48dp')
        .setTint('#FFFFFF')
        .setColor('#019581')
        .onClick((view, name) => {
            controlWindowSetVisibility(!controlWindowVisible);
            controlWindowVisible = !controlWindowVisible;
            //Return true: keep the menu open false: close the menu
            return false;
        });
    fb.addItem('退出脚本')
        .setIcon('@drawable/ic_exit_to_app_black_48dp')
        .setTint('#FFFFFF')
        .setColor('#019581')
        .onClick((view, name) => {
            //fb.close();
            evt.emit("exitApp");
            return true;
        });
    fb.show();
    
    // controlWindowSetVisibility(true)  //Convenient debugging
}


/**
 * @brief Parses and loads a music file, using file settings.
 * @param {string} fileName
 * @param {MusicLoaderDataType} loadType
 *
 * @typedef {Object} loadedMusicData
 * @property {import("./src/noteUtils.js").PackedNoteLike[]} packedKeyList
 * @property {import("./src/players.js").Gestures} [gestureList]
 * @property {string} summary
 * @returns {loadedMusicData?}
 */
function loadMusicFile(fileName, loadType) {
    ////////////// Display loading progress bar
    let progressDialog = dialogs.build({
        title: "Loading...",
        content: "Parsing file...",
        negative: "Cancel",
        progress: {
            max: 100,
            showMinMax: false
        },
        cancelable: true,
        canceledOnTouchOutside: false
    }).on("negative", () => {
        return;
    }).show();
    fileName = fileProvider.loadMusicFile(fileName);
    console.info("Loading music file: " + fileName);
    let rawFileName = musicFormats.getFileNameWithoutExtension(fileName);
    let startTime = new Date().getTime();

    ////////////// Load configuration
    if (!gameProfile.checkKeyPosition()) {
        dialogs.alert("Error", "Coordinates not set, please set the coordinates first");
        progressDialog.dismiss();
        runClickPosSetup();
        return null;
    };

    let humanifyNoteAbsTimeStdDev = readGlobalConfig("humanifyNoteAbsTimeStdDev", 0)
    let majorPitchOffset = configuration.readFileConfigForTarget("majorPitchOffset", rawFileName, gameProfile, 0);
    let minorPitchOffset = configuration.readFileConfigForTarget("minorPitchOffset", rawFileName, gameProfile, 0);
    let wrapHigherOctave = configuration.readFileConfigForTarget("wrapHigherOctave", rawFileName, gameProfile, 1);
    let wrapLowerOctave = configuration.readFileConfigForTarget("wrapLowerOctave", rawFileName, gameProfile, 0);
    let semiToneRoundingMode = readFileConfig("semiToneRoundingMode", rawFileName, 0);
    let limitClickSpeedHz = readFileConfig("limitClickSpeedHz", rawFileName, 0);
    let speedMultiplier = readFileConfig("speedMultiplier", rawFileName, 1);
    let noteDurationOutputMode = configuration.readFileConfigForTarget("noteDurationOutputMode", rawFileName, gameProfile, "none");
    let maxGestureDuration = readGlobalConfig("maxGestureDuration", 8000);
    let marginDuration = readGlobalConfig("marginDuration", 100);
    let defaultClickDuration = readGlobalConfig("defaultClickDuration", 5);
    let chordLimitEnabled = readFileConfig("chordLimitEnabled", rawFileName, false);
    let maxSimultaneousNoteCount = readFileConfig("maxSimultaneousNoteCount", rawFileName, 2);
    let noteCountLimitMode = readFileConfig("noteCountLimitMode", rawFileName, "split");
    let noteCountLimitSplitDelay = readFileConfig("noteCountLimitSplitDelay", rawFileName, 75);
    let chordSelectMode = readFileConfig("chordSelectMode", rawFileName, "high");
    let mergeThreshold = readFileConfig("mergeNearbyNotesInterval", rawFileName, 50);
    let lastSelectedTracksNonEmpty = configuration.readFileConfigForTarget("lastSelectedTracksNonEmpty", rawFileName, gameProfile);
    let keyRange = gameProfile.getKeyRange();

    console.log("Current music:" + fileName);
    console.log("Configuration information:");
    console.log("majorPitchOffset:" + majorPitchOffset);
    console.log("minorPitchOffset:" + minorPitchOffset);
    console.log("semiToneRoundingMode:" + semiToneRoundingMode);

    /**
     * @type {Array<passes.Pass>}
     */
    let pipeline = [];

    //Parse the document
    progressDialog.setContent("Parse the document...");
    // console.log("Parsing files is time-consuming" + elapsedTime / 1000 + "Seconds");
    pipeline.push(new passes.ParseSourceFilePass({}));
    //Select the audio track
    pipeline.push(new passes.RemoveEmptyTracksPass({}));
    pipeline.push(new passes.MergeTracksPass({
        selectedTracks: lastSelectedTracksNonEmpty,
        skipPercussion: true,
    }));
    pipeline.push(new passes.StoreCurrentNoteTimePass());
    //Change speed
    if (speedMultiplier != 1) {
        pipeline.push(new passes.SpeedChangePass({
            speed: speedMultiplier
        }));
    }
    //Merge keys
    pipeline.push(new passes.MergeKeyPass({
        maxInterval: mergeThreshold,
    }));
    //Disguise the handball
    if (humanifyNoteAbsTimeStdDev > 0) {
        pipeline.push(new passes.HumanifyPass({
            noteAbsTimeStdDev: humanifyNoteAbsTimeStdDev
        }));
    }
    //Convert to the sound range of the target game
    pipeline.push(new passes.PitchOffsetPass({
        offset: majorPitchOffset * 12 + minorPitchOffset
    }));
    pipeline.push(new passes.LegalizeTargetNoteRangePass({
        semiToneRoundingMode: semiToneRoundingMode,
        currentGameProfile: gameProfile,
        wrapHigherOctave: wrapHigherOctave,
        wrapLowerOctave: wrapLowerOctave
    }));
    //Frequency limit of a single key
    pipeline.push(new passes.SingleKeyFrequencyLimitPass({
        minInterval: gameProfile.getSameKeyMinInterval()
    }));
    //Skip the prelude
    if (readGlobalConfig("skipInit", true)) {
        pipeline.push(new passes.SkipIntroPass({}));
    }
    //Skip the blank space in the middle
    if (readGlobalConfig("skipBlank5s", true)) {
        pipeline.push(new passes.LimitBlankDurationPass({})); //默认5秒
    }
    //Limit the frequency of pressing buttons
    if (limitClickSpeedHz != 0) {
        pipeline.push(new passes.NoteFrequencySoftLimitPass({
            minInterval: 1000 / limitClickSpeedHz
        }));
    }
    //Limit the number of buttons at the same time
    if (chordLimitEnabled) {
        pipeline.push(new passes.ChordNoteCountLimitPass({
            maxNoteCount: maxSimultaneousNoteCount,
            limitMode: noteCountLimitMode,
            splitDelay: noteCountLimitSplitDelay,
            selectMode: chordSelectMode,
        }));
    }
    //Add lyrics
    const lrcPath = musicDir + rawFileName + ".lrc";
    if (files.exists(lrcPath)) {
        const lrcStr = files.read(lrcPath);
        const lrc = new LrcParser().parseFromString(lrcStr);
        console.log("Loaded" + lrc.length + "行歌词");
        pipeline.push(new passes.BindLyricsPass({
            lyrics: lrc,
            useStoredOriginalTime: true
        }));
    }
    //Convert to keys
    pipeline.push(new passes.NoteToKeyPass({
        currentGameProfile: gameProfile
    }));

    const sequential = new passes.SequentialPass({
        passes: pipeline
    });

    const data = sequential.run(musicDir + fileName, (progress, desc) => {
        progressDialog.setProgress(progress);
        progressDialog.setContent(desc + "...");
    });

    const stats = sequential.getStatistics();
    console.log(JSON.stringify(stats));
    const packedKeyList = noteUtils.packNotes(data)

    if (loadType != MusicLoaderDataType.GestureSequence) {
        //If the score is exported, there is no need to generate gestures.
        progressDialog.dismiss();
        return {
            packedKeyList: packedKeyList,
            summary: ""
        }
    }

    const finalNoteCnt = data.length;
    //Generate gestures
    progressDialog.setContent("生成手势...");
    const gestureTimeList = new passes.KeyToGesturePass({
        currentGameProfile: gameProfile,
        durationMode: noteDurationOutputMode,
        maxGestureDuration: maxGestureDuration,
        marginDuration: marginDuration,
        pressDuration: defaultClickDuration,
    }).run(data);
    progressDialog.dismiss();

    //Data summary
    const inputNoteCnt = stats.ParseSourceFilePass.totalNoteCnt;
    const overFlowedNoteCnt = stats.LegalizeTargetNoteRangePass.overFlowedNoteCnt;
    const underFlowedNoteCnt = stats.LegalizeTargetNoteRangePass.underFlowedNoteCnt;
    const roundedNoteCnt = stats.LegalizeTargetNoteRangePass.roundedNoteCnt;
    const droppedNoteCnt = stats.SingleKeyFrequencyLimitPass.droppedNoteCnt + stats.MergeKeyPass.droppedSameNoteCount;
    const outRangedNoteCnt = overFlowedNoteCnt + underFlowedNoteCnt;

    const statString = "The total number of notes:" + inputNoteCnt + " -> " + finalNoteCnt +
        "\nThe number of notes discarded beyond the range:" + outRangedNoteCnt + "" + " (+" + overFlowedNoteCnt + ", -" + underFlowedNoteCnt + ")(" + (outRangedNoteCnt / inputNoteCnt * 100).toFixed(2) + "%)" +
        "\nThe number of notes that have been iverted:" + roundedNoteCnt + " (" + (roundedNoteCnt / inputNoteCnt * 100).toFixed(2) + "%)" +
        "\nThe number of notes that are too densely discarded:" + droppedNoteCnt + " (" + (droppedNoteCnt / finalNoteCnt * 100).toFixed(2) + "%)" +
        "\n(If there are too many notes to be chosen, please select automatic adjustment in the menu)";
    const estimatedKey = midiPitch.getTranspositionEstimatedKey(minorPitchOffset);
    const hintString = `Estimate the tune of the music: ${estimatedKey}\n` + gameProfile.getGameSpecificHintByEstimatedKey(estimatedKey);

    dialogs.alert("Music information", statString + "\n\n" + hintString);
    return {
        packedKeyList: packedKeyList,
        gestureList: gestureTimeList,
        summary: statString
    }
}

function start() {
    /**
     * see: https://github.com/kkevsekk1/AutoX/issues/672
     */
    if (runtimes.getCurrentRuntime() == runtimes.Runtime.AUTOXJS) {
        try {
            // console.log("Width: " + device.width);
            //Java, Start up!!!
            let deviceClass = device.getClass();
            let widthField = deviceClass.getDeclaredField("width");
            let heightField = deviceClass.getDeclaredField("height");
            widthField.setAccessible(true);
            heightField.setAccessible(true);
            widthField.setInt(device, context.getResources().getDisplayMetrics().widthPixels);
            heightField.setInt(device, context.getResources().getDisplayMetrics().heightPixels);
            let rotationListener = new JavaAdapter(android.view.OrientationEventListener, {
                onOrientationChanged: function (orientation) {
                    widthField.setInt(device, context.getResources().getDisplayMetrics().widthPixels);
                    heightField.setInt(device, context.getResources().getDisplayMetrics().heightPixels);
                }
            }, context);
            rotationListener.enable();
        } catch (e) {
            console.warn("Workaround failed");
            console.error(e);
        }
    }

    //Get the real application name
    const packageManager = context.getPackageManager();
    appName = packageManager.getApplicationLabel(context.getApplicationInfo()).toString();
    initialize();
    loadConfiguration();
    main();
    console.info("Start-up completed");
}

start();